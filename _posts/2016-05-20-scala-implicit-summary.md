---
layout: post
title:  "Scala隐式转换总结"
categories: [scala]
---

最近在设计一个scala库的结构，基于现有开源库的扩展。遵守开放封闭原则，不想修改现有的代码，希望在其基础上加一些扩展内容。所以，系统的看了scala隐式转换的内容，并应用在扩展上。总结如下，使用的资料是scala作者Martin写的教材《Programming in Scala, 2rd》第21章，此章节开篇就强调了隐式转换的一个主要用途就是对现有库扩展，运气不能再好！

* 隐式转换是编译时操作，在type mismatch时，会自动寻找作用域内，**implicit**申明的内容。
* 关键字**implicit**的内容才作为隐式转换
* 有三种隐式转换：1)转成期望的类型，最常用;2)调用者转换，在设计函数库时常用，也就是我要使用的场景;3)参数隐式转换,在库设计时使用，<%（作为）和<:（左边是右边的子类）的区别。
* 伴随类中定义隐式转换，不用显示的import
* 隐式转换可能会冲突（ambiguous），在冲突时，使用名称区别使用。
* 不在作用域内的隐式转换，是不会被调用的（编译器不会越权操作）。
* 可以定义类的隐式转换，就避免了在伴随类里面写映射转换，可能会更优雅。我的库采用此方案。
* 隐式函数或对象也可以显示的使用。
* 函数后面跟一个**(implicit n:Numeric[ED])**可以使用n.toDouble(T)用于转化成double

先总结这些，后面再开发过程中，如果有更深入的理解，会更新此文章。